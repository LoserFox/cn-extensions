(function (Scratch) {
    "use strict";

    Scratch.translate.setup({
        "zh": {
            "control.extName": "控制",
            "control.repeatForSeconds": "重复执行 [TIME] 秒",
            "control.for_each_2": "对于 [VALUE1] 到 [VALUE2] 中的每一个 [VARIABLE] 重复",
            "control.for_in_string": "对于字符串 [STRING] 中的每一个 [VARIABLE] 重复",
            "control.helloWorld": "你好世界！",
            "control.foreverIf": "重复执行如果 [BOOL] 那么",
            "control.else": "否则",
            "control.doOnce": "执行一次",
            "control.thenLoopIf": "如果 [BOOL] 则重复",
            "control.if": "如果 [BOOL1] 那么",
            "control.elseIf": "否则如果 [BOOL2] 那么",
            "control.wait": "等待 [DURATION] [UNITS]",
            "control.stopSprite": "停止角色 [SPRITE]",
            "control.greenFlag": "重启项目",
            "control.switchCase": "执行分支: [INPUT]",
            "control.switchCaseCase": "分支条件: [INPUT]",
            "control.branch": "分支",
            "control.switchCaseDefault": "默认选项：",
            "control.seconds": "秒",
            "control.milliseconds": "毫秒",
            "control.microseconds": "微秒",
            "control.minutes": "分钟",
            "control.hours": "小时",
            "control.frames": "帧",
            "control.set_counter_step_size": "将计数器步长设为 [NUM]",
            "control.change_counter": "计数器 [MODE]",
            "control.clear": "归零",
            "control.increment": "增加",
            "control.reduction": "减少",
            "control.newThread": "新线程",
            "control.breakLoop": "退出重复 [ICON]"
        },
        "zh-tw": {
            "control.extName": "控制",
            "control.repeatForSeconds": "重複 [TIME] 秒",
            "control.for_each_2": "計數 [VARIABLE] 於 [VALUE1] 到 [VALUE2]",
            "control.for_in_string": "使用 [VARIABLE] 在字串 [STRING] 中重複",
            "control.helloWorld": "Hello world！",
            "control.foreverIf": "無限重複如果 [BOOL] 那麽",
            "control.else": "否則",
            "control.doOnce": "執行一次",
            "control.thenLoopIf": "如果 [BOOL] 條件滿足就重複",
            "control.if": "如果 [BOOL1] 那麽",
            "control.elseIf": "否則如果 [BOOL2] 那麽",
            "control.wait": "等待 [DURATION] [UNITS]",
            "control.stopSprite": "停止 [SPRITE]",
            "control.greenFlag": "重新開始",
            "control.switchCase": "選擇分支: [INPUT]",
            "control.switchCaseCase": "分支: [INPUT]",
            "control.branch": "分支",
            "control.switchCaseDefault": "預設：",
            "control.seconds": "秒",
            "control.milliseconds": "毫秒",
            "control.microseconds": "微秒",
            "control.minutes": "分鐘",
            "control.hours": "小時",
            "control.frames": "影格",
            "control.set_counter_step_size": "將計數器間距設為 [NUM]",
            "control.change_counter": "計數器 [MODE]",
            "control.clear": "重置",
            "control.increment": "累計",
            "control.reduction": "減少",
            "control.newThread": "新執行緒",
            "control.breakLoop": "退出重複 [ICON]"
        },
        "ja-Hira": {
            "control.extName": "せいぎょ",
            "control.repeatForSeconds": "[TIME] びょうかんくりかえす",
            "control.for_each_2": "[VALUE1] から [VALUE2] までのようそを [VARIABLE] にいれてくりかえす",
            "control.for_in_string": "[STRING] のテキストようそを [VARIABLE] にいれてくりかえす",
            "control.helloWorld": "ハローワールド！",
            "control.foreverIf": "もし [BOOL] なら、ずっと",
            "control.else": "でなければ",
            "control.doOnce": "さいしょに",
            "control.thenLoopIf": "をおこない、 [BOOL] ならくりかえす",
            "control.if": "もし [BOOL1] なら",
            "control.elseIf": "でなければ、もし [BOOL2] なら",
            "control.wait": "[DURATION] [UNITS] まつ",
            "control.stopSprite": "[SPRITE] をとめる",
            "control.greenFlag": "リスタート",
            "control.switchCase": "[INPUT] でじょうけんぶんき：",
            "control.switchCaseCase": "[INPUT] ならば：",
            "control.branch": "ぶんき",
            "control.switchCaseDefault": "ちがえば：",
            "control.seconds": "びょう",
            "control.milliseconds": "ミリびょう",
            "control.microseconds": "マイクロびょう",
            "control.minutes": "ふん（ぷん）",
            "control.hours": "じかん",
            "control.frames": "フレーム",
            "control.set_counter_step_size": "カウンターのステップサイズを [NUM] にする",
            "control.change_counter": "カウンターを [MODE]",
            "control.clear": "クリアする",
            "control.increment": "ぞうかさせる",
            "control.reduction": "げんしょうさせる",
            "control.newThread": "あたらしいすれっどをさくせいする",
            "control.breakLoop": "だっしゅつする [ICON]"
        },
        "ja": {
            "control.extName": "制御",
            "control.repeatForSeconds": "[TIME] 秒間くり返す",
            "control.for_each_2": "[VALUE1] から [VALUE2] までの要素を [VARIABLE] に入れて繰り返す",
            "control.for_in_string": "[STRING] のテキスト要素を [VARIABLE] に入れて繰り返す",
            "control.helloWorld": "ハローワールド！",
            "control.foreverIf": "もし [BOOL] なら、ずっと",
            "control.else": "でなければ",
            "control.doOnce": "最初に",
            "control.thenLoopIf": "を行い、 [BOOL] なら繰り返す",
            "control.if": "もし [BOOL1] なら",
            "control.elseIf": "でなければ、もし [BOOL2] なら",
            "control.wait": "[DURATION] [UNITS] 待つ",
            "control.stopSprite": "[SPRITE] を止める",
            "control.greenFlag": "リスタート",
            "control.switchCase": "[INPUT] で条件分岐：",
            "control.switchCaseCase": "[INPUT] ならば：",
            "control.branch": "分岐",
            "control.switchCaseDefault": "違えば：",
            "control.seconds": "秒",
            "control.milliseconds": "ミリ秒",
            "control.microseconds": "マイクロ秒",
            "control.minutes": "分",
            "control.hours": "時間",
            "control.frames": "フレーム",
            "control.set_counter_step_size": "カウンターのステップサイズを [NUM] にする",
            "control.change_counter": "カウンターを [MODE]",
            "control.clear": "クリアする",
            "control.increment": "増加させる",
            "control.reduction": "減少させる",
            "control.newThread": "新しいスレッドを作成する",
            "control.breakLoop": "脱出する [ICON]"
        }
    });
    const formatMessage = Scratch.translate;
    const lang = (id, defaultValue) => Scratch.translate({ id: id, default: defaultValue });

    const repeatIcon = '/static/blocks-media/default/repeat.svg';

    const { Cast, ArgumentType, BlockType } = Scratch;
    class Blocks {
        constructor() {
            this._counterStepSize = 1;
        }
        getInfo() {
            return {
                color1: '#FFAB19',
                color2: '#EC9C13',
                color3: '#CF8B17',
                id: 'CONTROL',
                name: lang('control.extName', 'Control'),
                blocks: [
                    {
                        blockType: BlockType.XML,
                        xml: `
                            <block id="for_each" type="control_for_each">
                                <value name="VALUE">
                                    <shadow type="math_whole_number">
                                        <field name="NUM">10</field>
                                    </shadow>
                                </value>
                            </block>
                        `
                    },
                    '---',
                    {
                        opcode: 'foreverIf',
                        blockType: BlockType.LOOP,
                        branchCount: 1,
                        isTerminal: true,
                        text: lang('control.foreverIf', 'forever if [BOOL] then'),
                        arguments: {
                            BOOL: {
                                type: ArgumentType.BOOLEAN
                            }
                        }
                    },
                    {
                        opcode: 'foreverIfElse',
                        blockType: BlockType.LOOP,
                        branchCount: 2,
                        isTerminal: true,
                        text: [
                            lang('control.foreverIf', 'forever if [BOOL] then'),
                            lang('control.else', 'else')
                        ],
                        arguments: {
                            BOOL: {
                                type: ArgumentType.BOOLEAN
                            }
                        }
                    },
                    '---',
                    {
                        opcode: 'doWhile',
                        blockType: BlockType.CONDITIONAL,
                        branchCount: 1,
                        text: [
                            lang('control.doOnce', 'do once:'),
                            lang('control.thenLoopIf', 'then loops if [BOOL]') +
                            '[LOOP_ICON]'
                        ],
                        arguments: {
                            BOOL: {
                                type: ArgumentType.BOOLEAN
                            },
                            LOOP_ICON: {
                                type: ArgumentType.IMAGE,
                                dataURI: repeatIcon,
                                flipRTL: true
                            }
                        }
                    },
                    '---',
                    {
                        opcode: 'ifElseIf',
                        blockType: BlockType.CONDITIONAL,
                        branchCount: 2,
                        text: [
                            lang('control.if', 'if [BOOL1] then'),
                            lang('control.elseIf', 'else if [BOOL2] then')
                        ],
                        arguments: {
                            BOOL1: {
                                type: ArgumentType.BOOLEAN
                            },
                            BOOL2: {
                                type: ArgumentType.BOOLEAN
                            }
                        }
                    },
                    {
                        opcode: 'ifElseIfElse',
                        blockType: BlockType.CONDITIONAL,
                        branchCount: 3,
                        text: [
                            lang('control.if', 'if [BOOL1] then'),
                            lang('control.elseIf', 'else if [BOOL2] then'),
                            lang('control.else', 'else')
                        ],
                        arguments: {
                            BOOL1: {
                                type: ArgumentType.BOOLEAN
                            },
                            BOOL2: {
                                type: ArgumentType.BOOLEAN
                            }
                        }
                    },
                    '---',
                    {
                        opcode: 'wait',
                        blockType: BlockType.COMMAND,
                        text: lang('control.wait', 'wait [DURATION] [UNITS]'),
                        arguments: {
                            DURATION: {
                                type: ArgumentType.NUMBER,
                                defaultValue: '1'
                            },
                            UNITS: {
                                type: ArgumentType.STRING,
                                menu: "TIME_UNITS"
                            }
                        }
                    },
                    '---',
                    {
                        opcode: 'stopSprite',
                        blockType: BlockType.COMMAND,
                        text: lang('control.stopSprite', 'stop [SPRITE]'),
                        arguments: {
                            SPRITE: {
                                type: ArgumentType.STRING,
                                defaultValue: ''
                            }
                        },
                        hideFromPalette: true
                    },
                    {
                        blockType: BlockType.XML,
                        xml: `
                            <block type="CONTROL_stopSprite">
                                <value name="SPRITE">
                                    <shadow type="control_create_clone_of_menu" />
                                </value>
                            </block>
                        `
                    },
                    '---',
                    {
                        opcode: 'greenFlag',
                        blockType: BlockType.COMMAND,
                        isTerminal: true,
                        text: lang('control.greenFlag', 'restart')
                    },
                    '---',
                    {
                        opcode: 'switch',
                        blockType: BlockType.CONDITIONAL,
                        branchCount: 1,
                        text: lang('control.switchCase', 'switch: [INPUT]'),
                        arguments: {
                            INPUT: {
                                type: ArgumentType.STRING,
                                defaultValue: ''
                            }
                        },
                        hideFromPalette: true
                    },
                    {
                        opcode: 'case',
                        blockType: BlockType.CONDITIONAL,
                        branchCount: 1,
                        text: lang('control.switchCaseCase', 'case: [INPUT]'),
                        arguments: {
                            INPUT: {
                                type: ArgumentType.STRING,
                                defaultValue: ''
                            }
                        },
                        hideFromPalette: true
                    },
                    {
                        blockType: BlockType.XML,
                        xml: `
                            <block type="CONTROL_switch">
                                <value name="INPUT">
                                    <shadow type="text">
                                        <field name="TEXT">${lang('control.branch', 'branch')}</field>
                                    </shadow>
                                </value>
                                <value name="SUBSTACK">
                                    <block type="CONTROL_case">
                                        <value name="INPUT">
                                            <shadow type="text">
                                                <field name="TEXT">${lang('control.branch', 'branch')}</field>
                                            </shadow>
                                        </value>
                                    </block>
                                </value>
                            </block>
                        `
                    },
                    {
                        opcode: 'default',
                        blockType: BlockType.CONDITIONAL,
                        branchCount: 1,
                        isTerminal: true,
                        text: lang('control.switchCaseDefault', 'default:')
                    },
                    '---',
                    {
                        blockType: BlockType.XML,
                        xml: `
                            <block type="control_get_counter"/>
                        `
                    },
                    {
                        opcode: 'setCounterStepSize',
                        blockType: BlockType.COMMAND,
                        text: lang('control.set_counter_step_size', 'set counter step size to [NUM]'),
                        arguments: {
                            NUM: {
                                type: ArgumentType.NUMBER,
                                defaultValue: '1'
                            }
                        }
                    },
                    {
                        opcode: 'changeCounter',
                        blockType: BlockType.COMMAND,
                        text: lang('control.change_counter', '[MODE] counter'),
                        arguments: {
                            MODE: {
                                type: ArgumentType.STRING,
                                menu: 'CHANGE_COUNTER'
                            }
                        }
                    },
                    '---',
                    {
                        opcode: 'newThread',
                        text: lang('control.newThread', 'new thread'),
                        branchCount: 1,
                        blockType: BlockType.CONDITIONAL,
                    }
                ],
                menus: {
                    TIME_UNITS: {
                        acceptReporters: false,
                        items: [
                            {
                                text: formatMessage({
                                    id: 'control.seconds',
                                    default: 'seconds',
                                }),
                                value: 'seconds'
                            },
                            {
                                text: formatMessage({
                                    id: 'control.milliseconds',
                                    default: 'milliseconds',
                                }),
                                value: 'milliseconds'
                            },
                            {
                                text: formatMessage({
                                    id: 'control.microseconds',
                                    default: 'microseconds',
                                }),
                                value: 'microseconds'
                            },
                            {
                                text: formatMessage({
                                    id: 'control.minutes',
                                    default: 'minutes',
                                }),
                                value: 'minutes'
                            },
                            {
                                text: formatMessage({
                                    id: 'control.hours',
                                    default: 'hours',
                                }),
                                value: 'hours'
                            },
                            {
                                text: formatMessage({
                                    id: 'control.frames',
                                    default: 'frames',
                                }),
                                value: 'frames'
                            }
                        ]
                    },
                    CHANGE_COUNTER: {
                        acceptReporters: false,
                        items: [
                            {
                                text: formatMessage({
                                    id: 'control.clear',
                                    default: 'clear',
                                }),
                                value: 'clear'
                            },
                            {
                                text: formatMessage({
                                    id: 'control.increment',
                                    default: 'increment',
                                }),
                                value: 'increment'
                            },
                            {
                                text: formatMessage({
                                    id: 'control.reduction',
                                    default: 'reduction',
                                }),
                                value: 'reduction'
                            }
                        ]
                    }
                }
            };
        }

        /**
         * 重复执行（）秒块。
         * @param {number} TIME 重复执行的时间。（秒）
         */
        repeatForSeconds(args, util) {
            // 这玩意的编译搁 “../../compiler/irgen” 这个文件里。
            const duration = Math.max(0, 1000 * Cast.toNumber(args.TIME));

            if (util.stackTimerNeedsInit()) {
                util.startStackTimer(duration);
                vm.runtime.requestRedraw();
            }

            if (!util.stackTimerFinished()) {
                util.startBranch(1, true);
                util.yield();
            }
        }

        /**
         * 简单的 for 循环，但是有两个值。
         * @param {object} VARIABLE 要操作的变量。 
         * @param {number} VALUE1 开始值。
         * @param {number} VALUE2 结束值。
         */
        for_each_2(args, util) {
            // 这玩意的编译搁 “../../compiler/irgen” 这个文件里。
            args.VALUE1 = Cast.toNumber(args.VALUE1);
            args.VALUE2 = Cast.toNumber(args.VALUE2);

            const variable = util.target.lookupOrCreateVariable(
                args.VARIABLE.id, args.VARIABLE.name);
            const up = args.VALUE1 < args.VALUE2;

            if (typeof util.stackFrame.index === 'undefined') {
                if (up) util.stackFrame.index = Math.min(args.VALUE1, args.VALUE2) - 1;
                else util.stackFrame.index = Math.max(args.VALUE1, args.VALUE2) + 1;
            }

            if (up ? util.stackFrame.index < Math.max(args.VALUE1, args.VALUE2) :
                util.stackFrame.index > Math.min(args.VALUE1, args.VALUE2)) {
                up ? util.stackFrame.index++ : util.stackFrame.index--;
                variable.value = util.stackFrame.index;
                util.startBranch(1, true);
            }
        }

        /**
         * 简单的字符串的 for 循环。
         * @param {object} VARIABLE 要操作的变量。 
         * @param {string} STRING 遍历的字符串。 
         */
        for_in_string(args, util) {
            // 这玩意的编译搁 “../../compiler/irgen” 这个文件里。
            const inputString = String(args.STRING);
            const variable = util.target.lookupOrCreateVariable(
                args.VARIABLE.id, args.VARIABLE.name);

            if (typeof util.stackFrame.index === 'undefined') {
                util.stackFrame.index = 0;
                util.stackFrame.str = '';
            }

            if (util.stackFrame.index < inputString.length) {
                util.stackFrame.str = inputString[util.stackFrame.index];
                util.stackFrame.index++;
                variable.value = util.stackFrame.str;
                util.startBranch(1, true);
            }
        }

        foreverIf(args, util) {
            if (Cast.toBoolean(args.BOOL)) {
                util.startBranch(1, true);
            }
            else util.startBranch(2, true);
        }

        foreverIfElse(args, util) {
            const condition = Cast.toBoolean(args.BOOL);
            let branchCount = 1;
            if (!condition) branchCount = 2;
            util.startBranch(branchCount, true);
        }

        ifElseIf(args, util) {
            const condition1 = Cast.toBoolean(args.BOOL1);
            const condition2 = Cast.toBoolean(args.BOOL2);
            if (condition1) {
                util.startBranch(1, false);
            }
            else if (condition2) {
                util.startBranch(2, false);
            }
            else {
                util.startBranch(3, false);
            }
        }

        doWhile({ BOOL }, util) {
            if (!util.stackFrame.first) {
                util.stackFrame.first = true;
                util.startBranch(1, true);
            }
            else if (Cast.toBoolean(BOOL)) {
                util.startBranch(1, true);
            }
        }

        ifElseIfElse(args, util) {
            this.ifElseIf(args, util);
        }

        wait(args, util) {
            const duration = Math.max(0, Cast.toNumber(args.DURATION));
            const units = args.UNITS || 'seconds';
            if (units !== 'frames') {
                if (util.stackTimerNeedsInit()) {
                    let waitTime = duration;
                    if (units === 'seconds') {
                        waitTime = duration * 1000;
                    } else if (units === 'milliseconds') {
                        waitTime = duration;
                    } else if (units === 'microseconds') {
                        waitTime = duration / 1000;
                    } else if (units === 'minutes') {
                        waitTime = duration * 1000 * 60;
                    } else if (units === 'hours') {
                        waitTime = duration * 1000 * 60 * 60;
                    }
                    util.startStackTimer(waitTime);
                    vm.runtime.requestRedraw()
                    util.yield();
                } else if (!util.stackTimerFinished()) {
                    util.yield();
                }
            }
            else {
                if (typeof util.stackFrame.loopCounter === "undefined") {
                    util.stackFrame.loopCounter = duration;
                }
                util.stackFrame.loopCounter--;
                if (util.stackFrame.loopCounter >= 0) {
                    util.yieldTick();
                }
            }
        }

        stopSprite(args, util) {
            const sprite = args.SPRITE;
            let target;
            if (sprite === '_myself_') {
                target = util.target;
            } else if (sprite === '_stage_') {
                target = vm.runtime.getTargetForStage();
            } else {
                target = vm.runtime.getSpriteTargetByName(sprite);
            }
            if (target) {
                vm.runtime.stopForTarget(target);
            }
        }

        greenFlag() {
            vm.greenFlag();
        }

        // switch 本来想写作用域功能，但是后面没有成功，就先这样子吧

        switch(args, util) {
            const varName = Cast.toString(args.INPUT);
            const thread = util.thread;
            thread.switchVar = varName;
            thread.switchScope = {};
            thread.switchBranches = [];
            util.startBranch(1, false);
        }

        case(args, util) {
            const varName = Cast.toString(args.INPUT);
            const thread = util.thread;
            const switchVar = thread.switchVar;
            const switchBranches = thread.switchBranches;

            if (switchVar === varName) {
                const branch = util.startBranch(1, false);
                switchBranches.push(branch);
                thread.switchVar = null;
            }
        }

        default(args, util) {
            const thread = util.thread;
            const switchBranches = thread.switchBranches;

            try {
                if (switchBranches.length === 0) {
                    util.startBranch(1, false);
                    delete thread.switchVar;
                }
            }
            catch { }
        }

        setCounterStepSize({ NUM }) {
            this._counterStepSize = Cast.toNumber(NUM);
        }

        changeCounter({ MODE }) {
            const ext_scratch3_control = vm.runtime.ext_scratch3_control;
            const stepSize = this._counterStepSize;
            if (MODE === 'clear') ext_scratch3_control._counter = 0;
            if (MODE === 'increment') ext_scratch3_control._counter += stepSize;
            if (MODE === 'reduction') ext_scratch3_control._counter -= stepSize;
        }

        newThread({ }, util) {
            let targetBranch = util.thread.target.blocks.getBranch(util.thread.peekStack(), 0);
            if (targetBranch) {
                util.sequencer.runtime._pushThread(targetBranch, util.target, {});
            }
        }
    }

    Scratch.extensions.register(new Blocks());
})(Scratch);